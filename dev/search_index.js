var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Types","page":"API","title":"Types","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Order = [:type, :constant]","category":"page"},{"location":"api/#Functions","page":"API","title":"Functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Order = [:macro, :function]","category":"page"},{"location":"api/#Documentation","page":"API","title":"Documentation","text":"","category":"section"},{"location":"api/#MCBench.AbstractFileBasedSampler","page":"API","title":"MCBench.AbstractFileBasedSampler","text":"abstract type AbstractFileBasedSampler <: AnySampler\n\nAn abstract type for file-based sampling algorithms that inherit from AnySampler.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCBench.AbstractKernel","page":"API","title":"MCBench.AbstractKernel","text":"get_mmd(s1::DensitySampleVector, s2::DensitySampleVector; g=0, N=0)\ncompute_bandwidth(x, y)\n\nFunctions to calculate the Maximum Mean Discrepancy (MMD) between two samples. This code is adapted from the IPMeasures.jl package. Please refer to the repository for the original implementation.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCBench.AnySampler","page":"API","title":"MCBench.AnySampler","text":"abstract type AnySampler\n\nAn abstract type that serves as a base for all sampling algorithms.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCBench.CsvBasedSampler","page":"API","title":"MCBench.CsvBasedSampler","text":"struct CsvBasedSampler <: AbstractFileBasedSampler\nIO funtionalities to read data from a set of CSV files.\n\n# Fields\n- `fbs::FileBasedSampler`: File-based sampler\n- `header::Vector{String}`: Header of the CSV file\n- `mask::Vector{Int}`: Mask to extract the desired columns\n- `info::String`: Information about the sampler\n\n# Constructors\n- `CsvBasedSampler(; fields...)`\n- `CsvBasedSampler(file_paths::Vector{String})`: Creates a `CsvBasedSampler` with the given vector of file paths.\n- `CsvBasedSampler(path::String)`: Creates a `CsvBasedSampler` with the given file path. This will load all files in the directory if the path is a directory.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCBench.DsvSampler","page":"API","title":"MCBench.DsvSampler","text":"struct DsvSampler{D<:DensitySampleVector} <: AbstractFileBasedSampler\nIO funtionalities to read data from a set of DensitySampleVector files.\n\n# Fields\n- `dsvs::Vector{D}`: Vector of file paths\n- `current_dsv_index::Int`: Index of the current file in the vector\n- `current_position::Int`: Position within the current file\n- `weighted::Bool`: Whether the samples are weighted\n- `total_samples::Int`: Total number of samples\n- `neff::Vector{Float64}`: Number of effective samples\n- `info::String`: Information about the sampler\n\n# Constructors\n- `DsvSampler(; fields...)`\n- `DsvSampler(dsvs::Vector{D})`: Creates a `DsvSampler` with the given vector of file paths.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCBench.DsvTestcase","page":"API","title":"MCBench.DsvTestcase","text":"struct DsvTestcase <: AbstractTestcase\n\nA struct representing a test case based on DensitySampleVectors. This is meant to be used as IIDs when the samples are precalculated and stored in a file. In that case samples should be read from the file converted to a DensitySampleVector and used as the test case.\n\nFields\n\nsampler::DS: The sampler that generates the samples.\ndim::N: The dimension of the test case.\ninfo::A: Additional information about the test case.\n\nConstructors\n\nDsvTestcase(s::DS, n::Int, info::A): Creates a test case with the given sampler, dimension and additional information.\nDsvTestcase(s::DS, info::A): Creates a test case with the given sampler and additional information. The dimension is set to the dimension of the samples.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCBench.FileBasedSampler","page":"API","title":"MCBench.FileBasedSampler","text":"struct FileBasesSampler <: SamplingAlgorithm\n\nIO funtionalities to read data from a set of files.\n\nFields\n\nfiles::Vector{String}: Vector of file paths.\ncurrent_file_index::Int: Index of the current file in the vector.\ncurrent_position::Int: Position within the current file.\ncurrent_file_handle::IOStream: Handle to the currently open file.\ninfo::String: Information about the sampler. Used for plotting.\n\nConstructors\n\nFileBasedSampler(; fields...)\nFileBasedSampler(file_paths::Vector{String}): Creates a FileBasedSampler with the given vector of file paths.\nFileBasedSampler(path::String): Creates a FileBasedSampler with the given file path. This will load all files in the directory if the path is a directory.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCBench.IIDSampler","page":"API","title":"MCBench.IIDSampler","text":"struct IIDSampler <: IIDSamplingAlgorithm\n\nA struct representing an IID (Independent and Identically Distributed) Sampler to created instances of IID sampling algorithms.\n\nFields\n\nn_steps::Int: The number of steps for the sampler. Identical to the number of samples for IID.\ninfo::String: Information or description of the sampler.\n\nConstructors\n\nIIDSampler(): Creates an IIDSampler with default values of 10^5 steps and \"IID\" as the info string.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCBench.IIDSamplingAlgorithm","page":"API","title":"MCBench.IIDSamplingAlgorithm","text":"abstract type IIDSamplingAlgorithm <: SamplingAlgorithm\n\nAn abstract type for independent and identically distributed (IID) sampling algorithms that inherit from SamplingAlgorithm. This type doesn't have any fields or methods, but it is used to have testfunctions reference their IID Base.rand method when sampling. \n\n\n\n\n\n","category":"type"},{"location":"api/#MCBench.SamplingAlgorithm","page":"API","title":"MCBench.SamplingAlgorithm","text":"abstract type SamplingAlgorithm <: AnySampler\n\nAn abstract type for general sampling algorithms that inherit from AnySampler.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCBench.Target","page":"API","title":"MCBench.Target","text":"abstract type AbstractTestcase\n\nAn abstract type for any test cases.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCBench.TestMetric","page":"API","title":"MCBench.TestMetric","text":"abstract type TestMetric\n\nAn abstract type for any test metrics. Each metric is its own struct and must implement the calc_metric function. Metrics are designed to be both structs that hold the metric value and determine which version of calc_metric to dispatch.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCBench.Testcases","page":"API","title":"MCBench.Testcases","text":"struct Testcases <: AbstractTestcase\n\nA struct representing a test case to be used in the framework of MCBench. Testcases must consisit of a distribution or Target that is sampleable and a set of bounds.\n\nFields\n\nf::D: The distribution or Target of the test case.\nbounds::B: The bounds of the test case.\ndim::N: The dimension of the test case.\ninfo::A: Additional information about the test case.\n\nConstructors\n\nTestcases(; fields...): Creates a test case with the given fields.\nTestcases(f::D, bounds::B, dim::N, info::A): Creates a test case with the given distribution or target, bounds, dimension and additional information.\nTestcases(f::D, dim::N, info::A): Creates a test case with the given distribution or target, dimension and additional information. Bounds are set to [-10..10] for each dimension.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCBench.TwoSampleMetric","page":"API","title":"MCBench.TwoSampleMetric","text":"abstract type TwoSampleMetric\n\nAn abstract type for any two-sample test metrics. Such as Wasserstein, MMD, etc.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCBench.chi_squared","page":"API","title":"MCBench.chi_squared","text":"struct chi_squared{V<:Real,A<:Any} <: TwoSampleMetric\n\n# Fields\n- `val::V`: The value of the metric.\n- `info::A`: Information about the metric.\n\n# Constructors\n- `chi_squared(; fields...)`\n- `chi_squared(val::Real)` : Creates a `chi_squared` metric with the given metric value.\n\nA struct for the chi_squared of the samples as a metric. \nThe chi-squared is calculated for each dimension separately using an unbinned chi-squared.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCBench.global_mode","page":"API","title":"MCBench.global_mode","text":"struct global_mode{V<:Real,A<:Any} <: TestMetric\n\n# Fields\n- `val::V`: The value of the metric.\n- `info::A`: Information about the metric.\n\n# Constructors\n- `global_mode(; fields...)`\n- `global_mode(val::Real)` : Creates a `global_mode` metric with the given metric value.\n\nA struct for the global mode of the samples as a metric. This will return the mode as a vector of the mode for each dimension.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCBench.marginal_kurtosis","page":"API","title":"MCBench.marginal_kurtosis","text":"struct marginal_kurtosis{V<:Real,A<:Any} <: TestMetric\n\n# Fields\n- `val::V`: The value of the metric.\n- `info::A`: Information about the metric.\n\n# Constructors\n- `marginal_kurtosis(; fields...)`\n- `marginal_kurtosis(val::Real)` : Creates a `marginal_kurtosis` metric with the given metric value.\n\nA struct for the marginal_kurtosis of the samples as a metric. Marginal kurtosis are calculated for each dimension of the samples and returned as a vector of `marginal_kurtosis` values.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCBench.marginal_mean","page":"API","title":"MCBench.marginal_mean","text":"struct marginal_mean{V<:Real,A<:Any} <: TestMetric\n\n# Fields\n- `val::V`: The value of the metric.\n- `info::A`: Information about the metric.\n\n# Constructors\n- `marginal_mean(; fields...)`\n- `marginal_mean(val::Real)` : Creates a `marginal_mean` metric with the given metric value.\n\nA struct for the mean value for each dimension of the samples as a metric.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCBench.marginal_mode","page":"API","title":"MCBench.marginal_mode","text":"struct marginal_mode{V<:Real,A<:Any} <: TestMetric\n\n# Fields\n- `val::V`: The value of the metric.\n- `info::A`: Information about the metric.\n\n# Constructors\n- `marginal_mode(; fields...)`\n- `marginal_mode(val::Real)` : Creates a `marginal_mode` metric with the given metric value.\n\nA struct for the marginal_mode of the samples as a metric. Marginal modes are calculated for each dimension of the samples and returned as a vector of `marginal_mode` values.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCBench.marginal_skewness","page":"API","title":"MCBench.marginal_skewness","text":"struct marginal_skewness{V<:Real,A<:Any} <: TestMetric\n\n# Fields\n- `val::V`: The value of the metric.\n- `info::A`: Information about the metric.\n\n# Constructors\n- `marginal_skewness(; fields...)`\n- `marginal_skewness(val::Real)` : Creates a `marginal_skewness` metric with the given metric value.\n\nA struct for the marginal_skewness of the samples as a metric. Marginal skewness are calculated for each dimension of the samples and returned as a vector of `marginal_skewness` values.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCBench.marginal_variance","page":"API","title":"MCBench.marginal_variance","text":"struct marginal_variance{V<:Real,A<:Any} <: TestMetric\n\n# Fields\n- `val::V`: The value of the metric.\n- `info::A`: Information about the metric.\n\n# Constructors\n- `marginal_variance(; fields...)`\n- `marginal_variance(val::Real)` : Creates a `marginal_variance` metric with the given metric value.\n\nA struct for the variance for each dimension of the samples as a metric.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCBench.maximum_mean_discrepancy","page":"API","title":"MCBench.maximum_mean_discrepancy","text":"struct maximum_mean_discrepancy{V<:Real,A<:Any} <: TwoSampleMetric\n\n# Fields\n- `val::V`: The value of the metric.\n- `N::I`: The number of points used to calculate the maximum mean discrepancy.\n- `info::A`: Information about the metric.\n- `proc::P`: The processor information for the metric.\n\n# Constructors\n- `maximum_mean_discrepancy(; fields...)`\n- `maximum_mean_discrepancy(val::Real)` : Creates a `maximum_mean_discrepancy` metric with the given metric value.\n- `maximum_mean_discrepancy(val::Real, N::Int)` : Creates a `maximum_mean_discrepancy` metric with the given metric value and number of points.\n\nA struct for the maximum_mean_discrepancy of the samples as a metric. \nPer default the number of points used to calculate the maximum mean discrepancy is 10^4.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCBench.sliced_wasserstein_distance","page":"API","title":"MCBench.sliced_wasserstein_distance","text":"struct sliced_wasserstein_distance{V<:Real,A<:Any} <: TwoSampleMetric\n\n# Fields\n- `val::V`: The value of the metric.\n- `N::I`: The number of points used to calculate the sliced Wasserstein distance.\n- `info::A`: Information about the metric.\n- `proc::P`: The processor information for the metric.\n\n# Constructors\n- `sliced_wasserstein_distance(; fields...)`\n- `sliced_wasserstein_distance(val::Real)` : Creates a `sliced_wasserstein_distance` metric with the given metric value.\n\nA struct for the sliced_wasserstein_distance of the samples as a metric. \nThe sliced Wasserstein distance is calculated by projecting the samples onto a random direction and calculating the Wasserstein distance in that direction.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCBench.wasserstein_1d","page":"API","title":"MCBench.wasserstein_1d","text":"struct wasserstein_1d{V<:Real,A<:Any} <: TwoSampleMetric\n\n# Fields\n- `val::V`: The value of the metric.\n- `info::A`: Information about the metric.\n\n# Constructors\n- `wasserstein_1d(; fields...)`\n- `wasserstein_1d(val::Real)` : Creates a `wasserstein_1d` metric with the given metric value.\n\nA struct for the wasserstein_1d of the samples as a metric. The Wasserstein distance is calculated for each dimension separately and returned as a vector of `wasserstein_1d` values.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCBench.build_teststat_reshuffle-Union{Tuple{T}, Tuple{TM}, Tuple{T, Int64, Vector{TM}, Vector{IOStream}}} where {TM<:MCBench.TestMetric, T<:MCBench.AbstractTestcase}","page":"API","title":"MCBench.build_teststat_reshuffle","text":"build_teststat_reshuffle(t<:AbstractTestcase, n::Int, m::Vector{TestMetric}, fnm::Vector{IOStream}; \n    s=IIDSampler(), n_steps=10^5, n_samples=0, unweight=true, par=false, use_sampler=true) -> Nothing\n\nThis function is prone to be changed mostly used for internal usage, please use the build_teststatistic function instead! Generates reshuffled test statistics for a given test case and metric vector, writing results to specified files.\n\nArguments\n\nt<:AbstractTestcase: The test case to be evaluated, is a subtype of AbstractTestcase.\nn::Int: Number of reshuffling iterations to perform.\nm::Vector{TM}: A vector of metrics to evaluate, where TM is a subtype of TestMetric.\nfnm::Vector{IOStream}: A vector of open file streams for writing test statistics.\n\nKeyword Arguments\n\ns: The sampling algorithm to use. Defaults to IIDSampler().\nn_steps::Int: Number of steps for the sampling algorithm. Defaults to 10^5.\nn_samples::Int: Number of samples to generate for each iteration. Defaults to 0 (use all available samples).\nunweight::Bool: Whether to resample based on effective sample size (ESS) when weights are unequal. Defaults to true.\npar::Bool: Enable parallel processing if true. Defaults to false.\nuse_sampler::Bool: Use the sampler for data generation if true. Defaults to true.\n\nReturns\n\nNothing: Results are written to the provided file streams.\n\nNotes\n\nHandles both cases of generating fixed or variable sample sizes (n_samples > 0 or n_samples <= 0).\nEnsures proper resampling when weights are unequal, maintaining consistent ESS.\nSupports parallel and sequential processing based on the par argument.\nAutomatically closes all file streams upon completion.\n\nExample\n\ntestcase = MyTestcase()\nmetrics = [Metric1(), Metric2()]\nfile_streams = [open(\"metric1.txt\", \"w\"), open(\"metric2.txt\", \"w\")]\nbuild_teststat_reshuffle(testcase, 100, metrics, file_streams; n_steps=10^4, unweight=true, par=false)\n\nError Handling\n\nEnsures file streams are closed in case of unexpected errors during execution.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCBench.build_teststatistic-Union{Tuple{TM}, Tuple{T}, Tuple{T, Vector{TM}}} where {T<:MCBench.AbstractTestcase, TM<:MCBench.TestMetric}","page":"API","title":"MCBench.build_teststatistic","text":"build_teststatistic(t<:AbstractTestcase, m::Vector{TestMetric}; \n    s=IIDSampler(), n::Int=10^2, n_steps::Int=10^5, \n    n_samples::Int=10^5, par::Bool=true, \n    clean::Bool=false, unweight::Bool=true, \n    use_sampler::Bool=true, iid=false)\n\nBuild and store test statistics for a given test case and multiple Metrics. This function manages file creation and invokes reshuffling and sampling to calculate the desired statistics. The resampling is performed n times according to the effective sample size of the provided sampler. Sampling is repeted until n samples of effective samples are generated.\n\nArguments\n\nt<:AbstractTestcase: The test case, is a subtype of AbstractTestcase.\nm::Vector{TM}: A vector of metrics, where TM is a subtype of TestMetric.\n\nKeyword Arguments\n\ns: A sampling algorithm. Defaults to IIDSampler().\nn::Int: Number of iterations aka the number of times the tests and calculations of the metrics is performed. Defaults to 10^2.\nn_steps::Int: Number of steps for the sampling algorithm. This setting is only necessary for samplers that require a fixed number of steps. This is not relevant if the number of steps is defined in the sampler object. Defaults to 10^5. \nn_samples::Int: Number of samples to generate. This setting referes to the number of IID samples. Defaults to 10^5. \npar::Bool: Whether to enable parallel processing. Defaults to true.\nclean::Bool: If true, clears the output files before calculation. Defaults to false.\nunweight::Bool: Whether to unweight samples during reshuffling. If false resampling to the effective sample size will be skipped. Defaults to true. \nuse_sampler::Bool: Whether to utilize the sampler in the calculations. This is only necessary for internal sampler types which have custom settings (like fixed number of steps). It will use the actual sampling object instead of creating a new instance of the sampler object with default settings and the number of steps in this function. Defaults to true.\niid::Bool: If true, forces IID behavior regardless of the sampler type. Can be used for IID to IID comparisons. Defaults to false.\n\nReturns\n\nNothing: Results are stored in specified files.\n\nNotes\n\nMake sure to have created teststatistics and teststatistics_sampler filepaths.\nFile paths are generated based on the info property of the test case, metric, and sampler.\nIf clean is true, all files are overwritten. Otherwise, results are appended.\nThe function ensures that files are properly closed, even in case of errors.\nReshuffling and sampling are handled by the build_teststat_reshuffle function.\n\nExample\n\nmetrics = [Metric1(), Metric2()]\ntestcase = MyTestcase()\nbuild_teststatistic(testcase, metrics; n=100, par=true, clean=true)\n\n\n\n\n\n","category":"method"},{"location":"api/#MCBench.calc_metric-Union{Tuple{AT}, Tuple{AT, StructArrays.StructArray{BAT.DensitySample{P, T, W, R, Q}, 1, @NamedTuple{v::PV, logd::TV, weight::WV, info::RV, aux::QV}} where {P, T<:AbstractFloat, W<:Real, R, Q, PV<:AbstractVector{P}, TV<:AbstractVector{T}, WV<:AbstractVector{W}, RV<:AbstractVector{R}, QV<:AbstractVector{Q}}, marginal_mean}} where AT<:MCBench.AbstractTestcase","page":"API","title":"MCBench.calc_metric","text":"calc_metric(t::AbstractTestcase, \ns::DensitySampleVector, \nm::TestMetric)\n\nCalculate the metric `m` for the test case `t` and the samples `s`.\nThis function is used to calculate the metric value for a given test case and samples for any metric type.\n`TwoSampleMetric` metrics can also be used, however the `calc_metric` then samples a second set of IID samples to compare against.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCBench.get_sliced_wasserstein_distance-Tuple{Any, Any}","page":"API","title":"MCBench.get_sliced_wasserstein_distance","text":"get_sliced_wasserstein_distance(dist1, dist2; d=50, L=1000, p=1, N=100_000)\n\nCompute the sliced Wasserstein distance between two probability distributions.\n\nArguments\n\ndist1: The first probability distribution.\ndist2: The second probability distribution.\nd: The dimension of the samples. Default is 50.\nL: The number of random projections. Default is 1000.\np: The norm order. Default is 1.\nN: The number of samples. Default is 100_000.\n\nReturns\n\nThe sliced Wasserstein distance between dist1 and dist2.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCBench.parse_teststatistic-Tuple{String}","page":"API","title":"MCBench.parse_teststatistic","text":"parse_teststatistic(filename::String)\n\nParses test statistics from a specified file.\n\nArguments\n\nfilename::String: The name of the file containing test statistics.\n\nReturns\n\nArray{Float64}: A reshaped array containing the parsed test statistics.\n\nNotes\n\nThe function reads lines from the file, parses them as JSON, and reshapes the resulting data.\n\nExample\n\nstatistics = parse_teststatistic(\"./teststatistics/example.txt\")\nprintln(statistics)\n\n\n\n\n\n","category":"method"},{"location":"api/#MCBench.parseline-Tuple{IOStream}","page":"API","title":"MCBench.parseline","text":"parseline(f::IOStream)\n\nParses a single line of JSON data from an open file stream.\n\nArguments\n\nf::IOStream: The open file stream from which the line is read.\n\nReturns\n\nVector{Float64}: A vector parsed from the JSON line.\n[]: An empty array if the line is empty.\n\nExample\n\nfile = open(\"./teststatistics/example.txt\", \"r\")\nline_data = parseline(file)\nclose(file)\nprintln(line_data)\n\n\n\n\n\n","category":"method"},{"location":"api/#MCBench.plot_teststatistic-Union{Tuple{TM}, Tuple{MCBench.AbstractTestcase, TM}} where TM<:MCBench.TestMetric","page":"API","title":"MCBench.plot_teststatistic","text":"plot_metrics(t::AbstractTestcase, normvals::Vector{NamedTuple}; plotalpha=0.2, infos=[], s=[]) \nplot_teststatistic(t::AbstractTestcase, m::TM) where {TM <: TestMetric}\nplot_teststatistic(t::AbstractTestcase, m::TM, s::AnySampler; nbins=32, same_bins=true,sampler_bins=false)\n\nFunctions to plot test statistics and overview plots for a given test case and metrics. These functions are subject to change and changed for recepies and are not guaranteed to be stable\n\nArguments\n\nt::AbstractTestcase: The open file stream from which the line is read.\nm::TM: The metric for which the test statistic is plotted.\ns::AnySampler: The sampling algorithm for which the test statistic is plotted.\nnbins::Int: The number of bins for the histogram.\nsame_bins::Bool: Whether to use the same bins for the test statistic and the sampling algorithm.\nsampler_bins::Bool: Whether to use the bins of the sampling algorithm for the test statistic or from the IID samples. This should be set to true as the distribution of the test statistics for the sampler i svery likely have a wider range than the IID samples.\n\nExample\n\nt = MyTestcase()\nm = [MyMetric_1(), MyMetric_2()]\ns = MySampler()\n\nplot_teststatistic(t, m, s; nbins=32, same_bins=true, sampler_bins=true)\nplot_metrics(t, normvals; plotalpha=0.2, infos=[], s=[])\n\n\n\n\n\n\n","category":"method"},{"location":"api/#MCBench.read_teststatistic-Union{Tuple{TM}, Tuple{MCBench.AbstractTestcase, TM}} where TM<:MCBench.TestMetric","page":"API","title":"MCBench.read_teststatistic","text":"read_teststatistic(t::AbstractTestcase, m::TM)\nread_teststatistic(t::AbstractTestcase, m::TM, s::AnySampler)\n\nFunctions to read test statistics from a file. Read test statistics for a given test case, metric, and optionally a sampling algorithm from a file.\n\nArguments\n\nt::AbstractTestcase: The test case for which the statistics are being read.\nm::TM: The metric, where TM is a subtype of TestMetric.\ns::AnySampler (optional): The sampling algorithm used to generate the statistics. If not givin the IID statistics are read.\n\nReturns\n\nArray{Float64}: A reshaped array containing the parsed test statistics.\n\nNotes\n\nConstructs the file name using t.info and m.info, and optionally s.info if a sampler is provided.\nReads and parses the contents of the file to extract the statistics.\n\nExample\n\ntestcase = MyTestcase()\nmetric = MyMetric()\nstatistics = read_teststatistic(testcase, metric)  # Without sampler\nprintln(statistics)\n\nsampler = MySampler()\nstatistics_with_sampler = read_teststatistic(testcase, metric, sampler)  # With sampler\nprintln(statistics_with_sampler)\n\n\n\n\n\n","category":"method"},{"location":"api/#MCBench.rep-Tuple{Any, Any}","page":"API","title":"MCBench.rep","text":"wasserstein1d(a::Vector, b::Vector; p=1, wa=nothing, wb=nothing)\nget_sliced_wasserstein_distance(sample1::DensitySampleVector, sample2::DensitySampleVector; L=1000, p=1, N=0, parallel=true)\n\nFunctions to calculate the Wasserstein distance between two 1D distributions and the sliced Wasserstein distance between two probability distributions. This code is adapted from the Transport package in R translated to Julia.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCBench.run_teststatistic-Union{Tuple{TM}, Tuple{TSM}, Tuple{TSM, StructArrays.StructArray{BAT.DensitySample{P, T, W, R, Q}, 1, @NamedTuple{v::PV, logd::TV, weight::WV, info::RV, aux::QV}} where {P, T<:AbstractFloat, W<:Real, R, Q, PV<:AbstractVector{P}, TV<:AbstractVector{T}, WV<:AbstractVector{W}, RV<:AbstractVector{R}, QV<:AbstractVector{Q}}, StructArrays.StructArray{BAT.DensitySample{P, T, W, R, Q}, 1, @NamedTuple{v::PV, logd::TV, weight::WV, info::RV, aux::QV}} where {P, T<:AbstractFloat, W<:Real, R, Q, PV<:AbstractVector{P}, TV<:AbstractVector{T}, WV<:AbstractVector{W}, RV<:AbstractVector{R}, QV<:AbstractVector{Q}}, TM, MCBench.SamplingAlgorithm}} where {TSM<:MCBench.AbstractTestcase, TM<:MCBench.TwoSampleMetric}","page":"API","title":"MCBench.run_teststatistic","text":"run_teststatistic(\nt::AbstractTestcase, \nsamples1::DensitySampleVector,\nsamples2::DensitySampleVector,\nm::TwoSampleMetric,\ns::SamplingAlgorithm;)\n\nrun_teststatistic(\nt::AbstractTestcase, \nsamples::DensitySampleVector,\nm::TwoSampleMetric, s::AnySampler;)\n\nrun_teststatistic(\nt::AbstractTestcase, \nsamples::DensitySampleVector,\nm::TwoSampleMetric, s::Int;)\n\nrun_teststatistic(\nt::AbstractTestcase, m::TwoSampleMetric,\ns::AnySampler; n_steps::Int=10^5)\n\nrun_teststatistic(\nt::AbstractTestcase, m::TwoSampleMetric;\nn_steps::Int=10^5)\n\nFunctions to run a two-sample test statistic on a given testcase and metric. When the samples are provided, the function calculates the metric value using the samples. When the sampling algorithm is provided, the function samples using the algorithm and the IID samples and calculates the metric value. When no samples and sampling algorithm are provided, the function samples using the testcase and calculates the metric value.\n\nArguments\n\nt::AbstractTestcase: The test case, is a subtype of AbstractTestcase.\nsamples1::DensitySampleVector: The first density sample vector.\nsamples2::DensitySampleVector: The second density sample vector.\nm::TwoSampleMetric: The metric, is a subtype of TwoSampleMetric.\ns::SamplingAlgorithm: The sampling algorithm used for calculations.\nn_steps::Int: The number of steps to be generated.\n\nReturns\n\nTwoSampleMetric: The calculated metric value.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCBench.sample-Tuple{DsvTestcase, Int64}","page":"API","title":"MCBench.sample","text":"sample(t::DsvTestcase; n_steps=10^5)::DensitySampleVector\nsample(t::DsvTestcase, s::SamplingAlgorithm; n_steps=10^5)::DensitySampleVector\n\nThe sample methods using DsvTestcase using the same logic as for Testcases but using the precalculated samples no matter the sampler used. \n\n\n\n\n\n","category":"method"},{"location":"api/#MCBench.sample-Tuple{Testcases}","page":"API","title":"MCBench.sample","text":"sample(t::Testcases; n_steps=10^5)::DensitySampleVector\nsample(t::Testcases, n::Int)::DensitySampleVector\nsample(t::Testcases, s::IIDSamplingAlgorithm; n_steps=10^5)::DensitySampleVector\n\nIID sampling from the distribution of the test case t with n_steps or n samples. When integrating a custom sampling algorithm, the sample method should be overloaded for the new sampling algorithm type for s. Returns a density sample vector with the samples and the log densities.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCBench.sample-Union{Tuple{FBA}, Tuple{AT}, Tuple{AT, FBA}} where {AT<:MCBench.AbstractTestcase, FBA<:MCBench.AbstractFileBasedSampler}","page":"API","title":"MCBench.sample","text":"sample(t<:AbsatractTestcase, s<:AbstractFileBasedSampler; n_steps=10^5)::DensitySampleVector\n\nSampling from the distribution of the test case t using a file-based sampler s with n_steps samples. The test case is not used in the sampling process, but it is used to calculate the log densities of the samples.  Returns a density sample vector with the samples and the log densities.\n\n\n\n\n\n","category":"method"},{"location":"testcases/#List-of-test-cases","page":"Test cases & Metrics","title":"List of test cases","text":"","category":"section"},{"location":"testcases/","page":"Test cases & Metrics","title":"Test cases & Metrics","text":"The following table contains all test cases currently available in the benchmark suite. When implementing one of these into the MC sampling framework of your choice, you can use the given testpoints to validate your implementation.   We provide example implementations of the listed test cases to be used with Julia, Python, R and Stan.   This table is not yet complete and will be extended   ","category":"page"},{"location":"testcases/","page":"Test cases & Metrics","title":"Test cases & Metrics","text":"Name Equation Parameters Testpoints Julia Python R Stan\nStandard Normal 1D f(xmu sigma) =frac1sqrt2pisigma^2 e^-frac(x - mu)^22sigma^2 mu = 0 sigma = 0 f(x=0) = 039894228, f(x=1) = 024197072 ✅ ✅ ✅ ✅\nStandard Normal 2D Uncorrelated f(x boldsymbolmu boldsymbolSigma) = (2pi)^-k2det (boldsymbolSigma)^-12 exp left( -frac12 (mathbfx - boldsymbolmu)^mathrmT boldsymbolSigma^-1(mathbfx - boldsymbolmu) right) k=2 mu=textttzeros(2) Sigma= I_2 f(x=0 0) = 015915494, f(x=0 1) = 0096532352, f(x=-1 1) = 00585498315 ✅ ✅ ✅ ✅\nStandard Normal 3D Uncorrelated f(x boldsymbolmu boldsymbolSigma) = (2pi)^-k2det (boldsymbolSigma)^-12 exp left( -frac12 (mathbfx - boldsymbolmu)^mathrmT boldsymbolSigma^-1(mathbfx - boldsymbolmu) right) k=3 mu=textttzeros(3) Sigma= I_3 f(x=0 0 0) = 0063493636, f(x=1 1 1) = 0014167345, f(x=-1 0 1) = 00233580033 ✅ ✅ ✅ ✅","category":"page"},{"location":"testcases/#List-of-metrics","page":"Test cases & Metrics","title":"List of metrics","text":"","category":"section"},{"location":"testcases/","page":"Test cases & Metrics","title":"Test cases & Metrics","text":"The following metrics are available to compare custom generated MC samples to IID samples.","category":"page"},{"location":"testcases/#One-sample-metrics","page":"Test cases & Metrics","title":"One-sample metrics","text":"","category":"section"},{"location":"testcases/","page":"Test cases & Metrics","title":"Test cases & Metrics","text":"Marginal mean: marginal_mean()\nMarginal variance: marginal_variance()\nGlobal mode: global_mean()\nMarginal mode: marginal_mode()\nMarginal skewness: marginal_skewness()\nMarginal kurtosis: marginal_kurtosis()","category":"page"},{"location":"testcases/#Two-sample-metric","page":"Test cases & Metrics","title":"Two-sample metric","text":"","category":"section"},{"location":"testcases/","page":"Test cases & Metrics","title":"Test cases & Metrics","text":"Chi-squared: chi_squared()\nSliced Wasserstein Distance: sliced_wasserstein_distance()\nMaximum Mean Discrepancy: maximum_mean_discrepancy()","category":"page"},{"location":"LICENSE/#LICENSE","page":"LICENSE","title":"LICENSE","text":"","category":"section"},{"location":"LICENSE/","page":"LICENSE","title":"LICENSE","text":"using Markdown\nMarkdown.parse_file(joinpath(@__DIR__, \"..\", \"..\", \"LICENSE.md\"))","category":"page"},{"location":"#MCBench-Monte-Carlo-Sampling-Benchmark-Suite","page":"Home","title":"MCBench - Monte Carlo Sampling Benchmark Suite","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The MCBench benchmark suite is designed for quantitative comparisons of Monte Carlo (MC) samples. It offers a standardized method for evaluating MC sample quality and provides researchers and practitioners with a tool for validating, developing, and refining MC sampling algorithms.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For benchmarking, different metrics are applied to point clouds of both independent and identically distributed (iid) samples and correlated samples generated by MC techniques, such as Markov Chain Monte Carlo or Nested Sampling. Through repeated comparisons, test statistics of the metrics are gathered allowing to evaluate the quality of the MC samples. A variety of target functions with different complexities and dimensionalities are availble, providing a versatile platform for testing the capabilities of sampling algorithms.","category":"page"},{"location":"","page":"Home","title":"Home","text":"MCBench is implemented as Julia package but users can run external sampling algorithms of their choice on these test functions and input the resulting samples to obtain detailed metrics that quantify the quality of their samples compared to the iid samples generated by MCBench.","category":"page"},{"location":"#Workflow","page":"Home","title":"Workflow","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pick a test cases from the list of available target functions. \nImplement these functions into the sampling software of your choice. We provide basic implementations of the listed test cases in Julia, Python (to be used with PyMC) and Stan.\nGenerate samples of the target functions with the algorithm you want to benchmark. Save the samples as a .csv file with nparameters columns and nsamples rows.\nUse the Julia package MCBench to load your samples and benchmark them against IID samples (which are automatically generated by the package).\nSee Using MCBench for an example on how to use the MCBench package.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: workflow)","category":"page"},{"location":"tutorial/#Using-MCBench","page":"Tutorial","title":"Using MCBench","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This is a simple example of how to use the MCBench package. ","category":"page"},{"location":"tutorial/#Specify-the-test-case","page":"Tutorial","title":"Specify the test case","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"f = MvNormal(zeros(3), I(3))\nbounds = NamedTupleDist(x = [-10..10 for i in 1:3])\nStandard_Normal_3D_Uncorrelated = Testcases(f,bounds,3,\"Normal-3D-Uncorrelated\")","category":"page"},{"location":"tutorial/#Selecting-the-metrics-to-be-applied","page":"Tutorial","title":"Selecting the metrics to be applied","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"metrics = [marginal_mean(), marginal_variance(), sliced_wasserstein_distance(), maximum_mean_discrepancy()]","category":"page"},{"location":"tutorial/#Load-the-external-MC-samples-to-be-tested","page":"Tutorial","title":"Load the external MC samples to be tested","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"sampler = FileBasedSampler(\"samples_from_my_algorithm.csv\")","category":"page"},{"location":"tutorial/#Generating-the-teststatistics","page":"Tutorial","title":"Generating the teststatistics","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Evaluate the metrics both","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"for the IID samples (IID samples are generated automatically in the background):","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"teststatistics_IID = build_teststatistic(Standard_Normal_3D_Uncorrelated, metrics,\nn=100, n_steps=10^5, n_samples=10^5)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"and for the MC samples to be tested:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"teststatistics_my_samples = build_teststatistic(Standard_Normal_3D_Uncorrelated, metrics,\nn=100, n_steps=10^5, n_samples=10^5, s=sampler)","category":"page"},{"location":"tutorial/#Generating-comparison-plots","page":"Tutorial","title":"Generating comparison plots","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Overview plot of all selected metrics","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"plot_metrics(Standard_Normal_3D_Uncorrelated, metrics, sampler)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"<img src=\"../images/Normal-3D-Uncorrelated-metrics.svg\" width=\"480\"/>","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Individual metrics","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"plot_teststatistic(Standard_Normal_3D_Uncorrelated, marginal_mean(), sampler, nbins=20)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"<img src=\"../images/Normal-3D-Uncorrelated-SlicedWasserstein.svg\" width=\"480\"/>","category":"page"}]
}
